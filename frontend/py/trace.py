# pywiz_tracer.py
import sys, json, io, time, inspect, linecache, traceback, builtins
USER_FILENAME = "<user_code>"

EXCLUDE_LOCAL_KEYS = {"__builtins__", "__package__", "__loader__", "__spec__", "__doc__", "__annotations__"}
def _exclude_local(k, v): return k in EXCLUDE_LOCAL_KEYS or (k.startswith("__") and k.endswith("__"))

def safe(val):
    try: return json.loads(json.dumps(val, default=str))
    except Exception: return str(val)

def format_user_error(e):
    """
    Produce a short, user-focused message.
    Handles SyntaxError/IndentationError separately because they happen at compile time.
    """
    # --- compile-time errors ---
    if isinstance(e, SyntaxError):
        line = (e.text or "").rstrip("\n")
        caret = ""
        if e.offset and line:
            caret = " " * (e.offset - 1) + "^"
        return (
            f"{e.__class__.__name__} on line {e.lineno}:\n"
            f"    {line}\n"
            f"    {caret}\n"
            f"→ {e.msg}"
        )

    # --- runtime errors: filter traceback to USER_FILENAME ---
    tb = traceback.extract_tb(e.__traceback__)
    user_frames = [f for f in tb if f.filename == USER_FILENAME]

    if user_frames:
        f = user_frames[-1]
        line = (f.line or "").strip()
        return (
            f"{e.__class__.__name__} on line {f.lineno}:\n"
            f"    {line}\n"
            f"→ {e}"
        )

    return f"{e.__class__.__name__}: {e}"


def trace_exec(code_text: str) -> str:
    # ---- tracer state ----
    trace, stdout_buf = [], io.StringIO()
    _last_locals_by_fid = {}; _next_fid = 1
    fid_by_frame = {}; parent_fid = {}; depth_by_frame = {}
    _step = 0; _prev_ts = None; _last_out_len = 0

    def safe_print(*args, **kwargs):
        print(*args, **kwargs, file=stdout_buf)

    orig_input = builtins.input  # keep the real one

    def traced_input(prompt: str = ""):
        nonlocal _last_out_len

        # find the user frame that called input()
        cf = inspect.currentframe()
        frame = cf.f_back if cf is not None else None
        if frame is not None and frame.f_code.co_filename == USER_FILENAME:
            ensure_parent_depth(frame)
            fid = get_fid(frame)
            pf = parent_fid.get(id(frame))
            dep = depth_by_frame.get(id(frame), 0)
            func_name = frame.f_code.co_name
            line_no = frame.f_lineno
        else:
            fid = None
            pf = None
            dep = 0
            func_name = "<input>"
            line_no = 0

        step, ts, dt = tick()

        # actually read input (or you can stub this)
        value = orig_input(prompt)

        ev = {
            "step": step,
            "ts": ts,
            "dt": dt,
            "event": "Input",          # matches your capitalization style
            "func": func_name,
            "line": line_no,
            "fid": fid,
            "parent": pf,
            "depth": dep,
            "prompt": safe(prompt),
            "value": safe(value),
            # Optional helper string if you want:
            "label": f"User entered: {safe(value)}",
        }

        # capture any new stdout generated by the prompt
        full = stdout_buf.getvalue()
        if len(full) > _last_out_len:
            ev["out+"] = full[_last_out_len:]
            _last_out_len = len(full)

        trace.append(ev)
        return value

    SAFE_BUILTINS = {
        'abs': abs, 'min': min, 'max': max, 'range': range, 'len': len, 'print': safe_print,
        'bool': bool, 'int': int, 'float': float, 'str': str, 'list': list, 'dict': dict,
        'set': set, 'tuple': tuple, 'enumerate': enumerate, 'zip': zip, 'sum': sum, 'input': traced_input,
    }

    def get_fid(frame):
        nonlocal _next_fid
        k = id(frame)
        if k not in fid_by_frame:
            fid_by_frame[k] = _next_fid; _next_fid += 1
        return fid_by_frame[k]

    def ensure_parent_depth(frame):
        k = id(frame)
        if k in depth_by_frame: return
        p = frame.f_back; pfid = None; pdepth = -1
        while p:
            if p.f_code.co_filename == USER_FILENAME:
                pfid = get_fid(p); pdepth = depth_by_frame.get(id(p), pdepth); break
            p = p.f_back
        parent_fid[k] = pfid; depth_by_frame[k] = pdepth + 1

    def locals_patch(fid, f_locals):
        prev = _last_locals_by_fid.get(fid, {})
        filtered = {k: v for k, v in f_locals.items() if not _exclude_local(k, v)}
        curr = {k: safe(v) for k, v in filtered.items()}
        changed_locals, previous_locals = {}, {}
        for k, v in curr.items():
            if k not in prev or prev[k] != v:
                changed_locals[k] = v
                if k in prev: previous_locals[k] = prev[k]
        _last_locals_by_fid[fid] = curr
        return changed_locals, previous_locals

    def tick():
        nonlocal _step, _prev_ts
        _step += 1
        now = time.perf_counter_ns()
        dt = 0 if _prev_ts is None else now - _prev_ts
        _prev_ts = now
        return _step, now, dt

    def tracer(frame, event, arg):
        nonlocal _last_out_len
        if frame.f_code.co_filename != USER_FILENAME or event not in ("call","line","return","exception"):
            return tracer

        ensure_parent_depth(frame)
        fid = get_fid(frame)
        pf = parent_fid.get(id(frame))
        dep = depth_by_frame.get(id(frame), 0)
        step, ts, dt = tick()
        ev = {
            "step": step, "ts": ts, "dt": dt,
            "event": "Exception" if event=="exception" else event.capitalize(),
            "func": frame.f_code.co_name, "line": frame.f_lineno,
            "fid": fid, "parent": pf, "depth": dep,
        }

        if event == "call":
            args, varargs, varkw, values = inspect.getargvalues(frame)
            call_args = {a: safe(values[a]) for a in args if a in values}
            if varargs and varargs in values: call_args["*"+varargs] = safe(values[varargs])
            if varkw and varkw in values: call_args["**"+varkw] = safe(values[varkw])
            if call_args: ev["args"] = call_args
            changed_locals, prev_locals = locals_patch(fid, frame.f_locals)
            if changed_locals: ev["set"]=changed_locals; ev["prev"]=prev_locals

        elif event == "line":
            changed_locals, prev_locals = locals_patch(fid, frame.f_locals)
            if changed_locals: ev["set"]=changed_locals; ev["prev"]=prev_locals

        elif event == "return":
            ev["return"] = safe(arg)

        elif event == "exception":
            et, evv, _tb = arg
            ev["exc_type"] = getattr(et, "__name__", str(et))
            ev["exc"] = str(evv)

        full = stdout_buf.getvalue()
        if len(full) > _last_out_len:
            ev["out+"] = full[_last_out_len:]
            _last_out_len = len(full)

        trace.append(ev)
        if event == "return":
            k = id(frame)
            fid_by_frame.pop(k, None); parent_fid.pop(k, None); depth_by_frame.pop(k, None)
        return tracer

    # preload source for nice line lookups later
    linecache.cache[USER_FILENAME] = (
        len(code_text), None, [l + "\n" for l in code_text.splitlines()], USER_FILENAME
    )

    env = {"__builtins__": SAFE_BUILTINS, "__name__": "__main__"}
    sys.settrace(tracer)

    try:
        compiled = compile(code_text, USER_FILENAME, "exec")
        exec(compiled, env, env)

        return json.dumps({
            "ok": True,
            "filename": USER_FILENAME,
            "code": code_text,
            "trace": trace
        })
    
    except EOFError:
        # Code called input() but there was nothing in stdin
        return json.dumps({
            "ok": False,
            "filename": USER_FILENAME,
            "code": code_text,
            "trace": trace,
            "error": "Your code called input(), but no input was provided. \n Please add input in the Input box and try again."
        })

    except Exception as e:
        return json.dumps({
            "ok": False,
            "filename": USER_FILENAME,
            "code": code_text,
            "trace": trace,   # trace up to crash (if any)
            "error": format_user_error(e)
        })
    
    finally:
        sys.settrace(None)
